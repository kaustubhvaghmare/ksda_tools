"""
Program accepts those rotation curves generated by the GetCurve.py program
and displays them in alternate forms as well as saves them.
"""

import sys
import matplotlib.pyplot as plt
from MatplotlibCustom import *
import numpy as np
from astropy.table import Table
import scipy.interpolate as si
from RotationCurveLib import *

# Read command line arguments.
curves = sys.argv[1:]

interactive = raw_input("Interactive mode? (y/Other): ").lower()
if interactive == "y":
	interactive = True
else:
	interactive = False

# Run a loop over all curves.
fig1 = plt.figure(1, figsize=(6,6))
for curve in curves:
	tab = Table.read(curve, format="ascii")
	filtered = FilterErrorBars(tab["Vhel_err"])
	filtered2 = MeanSigmaClipper(tab["Vhel"], sigma=2.5)
	tab = tab[ (filtered & filtered2) ]

	# Perform a simple spline fit to the curve.
	# The order and other details don't matter
	# since the only purpose of the curve is to
	# simply give the velocity at zero so that 
	# rotation curve in relative velocities may
	# be obtaine.
	sortind = np.argsort(tab["DFCG"])
	spline_hv = si.UnivariateSpline( tab["DFCG"][sortind], tab["Vhel"][sortind], 1/tab["Vhel_err"][sortind], s=1)
	central_hv = spline_hv(0.0)
	rot_vel = tab["Vhel"] - central_hv

	# Make plot of 1st kind.
	plt.errorbar( tab["DFCG"], rot_vel, tab["Vhel_err"] ,fmt="o")
	plt.xlabel("Distance from Centre [arcsec]", fontsize=14)
	plt.ylabel("Rotation Velocity", fontsize=14)
	plt.title("Central Velocity = %.3f" % central_hv, fontsize=14)
	if interactive:
		plt.show()
		raw_input()
	fig1.savefig(curve+"_rc.png", dpi=150)
	plt.clf()

	# Make plot of 2nd kind
	plt.errorbar( np.abs(tab["DFCG"]), np.abs(rot_vel), tab["Vhel_err"],fmt="o")
	plt.xlabel("Distance from Centre [arcsec]", fontsize=14)
	plt.ylabel("Rotation Velocity", fontsize=14)
	plt.title("Central Velocity = %.3f" % central_hv, fontsize=14)
	plt.xlim( 0, np.max(np.abs(tab["DFCG"]))+2)
	if interactive:
		plt.show()
		raw_input()
	fig1.savefig(curve+"_rc2.png", dpi=150)
	plt.clf()




